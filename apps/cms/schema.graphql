# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
  id: ID!
  name: String
  email: String
  password: PasswordState
}

type PasswordState {
  isSet: Boolean!
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  name: String
  email: String
  password: String
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  email: String
  password: String
}

type Action {
  id: ID!
  title: String
  slug: String
  keywords: String
  resume: String
  content: Action_content_Document
  image: ImageFieldOutput
  date: CalendarDay
  publishedAt: DateTime
  status: String
}

type Action_content_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

type ImageFieldOutput {
  id: ID!
  filesize: Int!
  width: Int!
  height: Int!
  extension: ImageExtension!
  url: String!
}

enum ImageExtension {
  jpg
  png
  webp
  gif
}

scalar CalendarDay @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input ActionWhereUniqueInput {
  id: ID
  slug: String
}

input ActionWhereInput {
  AND: [ActionWhereInput!]
  OR: [ActionWhereInput!]
  NOT: [ActionWhereInput!]
  id: IDFilter
  title: StringFilter
  slug: StringFilter
  keywords: StringFilter
  resume: StringFilter
  date: CalendarDayFilter
  publishedAt: DateTimeNullableFilter
  status: StringFilter
}

input CalendarDayFilter {
  equals: CalendarDay
  in: [CalendarDay!]
  notIn: [CalendarDay!]
  lt: CalendarDay
  lte: CalendarDay
  gt: CalendarDay
  gte: CalendarDay
  not: CalendarDayFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input ActionOrderByInput {
  id: OrderDirection
  title: OrderDirection
  slug: OrderDirection
  keywords: OrderDirection
  resume: OrderDirection
  date: OrderDirection
  publishedAt: OrderDirection
  status: OrderDirection
}

input ActionUpdateInput {
  title: String
  slug: String
  keywords: String
  resume: String
  content: JSON
  image: ImageFieldInput
  date: CalendarDay
  publishedAt: DateTime
  status: String
}

input ImageFieldInput {
  upload: Upload!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input ActionUpdateArgs {
  where: ActionWhereUniqueInput!
  data: ActionUpdateInput!
}

input ActionCreateInput {
  title: String
  slug: String
  keywords: String
  resume: String
  content: JSON
  image: ImageFieldInput
  date: CalendarDay
  publishedAt: DateTime
  status: String
}

type Project {
  id: ID!
  title: String
  slug: String
  keywords: String
  content: Project_content_Document
  image: ImageFieldOutput
  link: String
  startDate: CalendarDay
  endDate: CalendarDay
  researchers(where: ResearcherWhereInput! = {}, orderBy: [ResearcherOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ResearcherWhereUniqueInput): [Researcher!]
  researchersCount(where: ResearcherWhereInput! = {}): Int
  researchArea: ResearchArea
  publishedAt: DateTime
  status: String
}

type Project_content_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

input ProjectWhereUniqueInput {
  id: ID
  slug: String
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  id: IDFilter
  title: StringFilter
  slug: StringFilter
  keywords: StringFilter
  link: StringFilter
  startDate: CalendarDayFilter
  endDate: CalendarDayFilter
  researchers: ResearcherManyRelationFilter
  researchArea: ResearchAreaWhereInput
  publishedAt: DateTimeNullableFilter
  status: StringFilter
}

input ResearcherManyRelationFilter {
  every: ResearcherWhereInput
  some: ResearcherWhereInput
  none: ResearcherWhereInput
}

input ProjectOrderByInput {
  id: OrderDirection
  title: OrderDirection
  slug: OrderDirection
  keywords: OrderDirection
  link: OrderDirection
  startDate: OrderDirection
  endDate: OrderDirection
  publishedAt: OrderDirection
  status: OrderDirection
}

input ProjectUpdateInput {
  title: String
  slug: String
  keywords: String
  content: JSON
  image: ImageFieldInput
  link: String
  startDate: CalendarDay
  endDate: CalendarDay
  researchers: ResearcherRelateToManyForUpdateInput
  researchArea: ResearchAreaRelateToOneForUpdateInput
  publishedAt: DateTime
  status: String
}

input ResearcherRelateToManyForUpdateInput {
  disconnect: [ResearcherWhereUniqueInput!]
  set: [ResearcherWhereUniqueInput!]
  create: [ResearcherCreateInput!]
  connect: [ResearcherWhereUniqueInput!]
}

input ResearchAreaRelateToOneForUpdateInput {
  create: ResearchAreaCreateInput
  connect: ResearchAreaWhereUniqueInput
  disconnect: Boolean
}

input ProjectUpdateArgs {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateInput!
}

input ProjectCreateInput {
  title: String
  slug: String
  keywords: String
  content: JSON
  image: ImageFieldInput
  link: String
  startDate: CalendarDay
  endDate: CalendarDay
  researchers: ResearcherRelateToManyForCreateInput
  researchArea: ResearchAreaRelateToOneForCreateInput
  publishedAt: DateTime
  status: String
}

input ResearcherRelateToManyForCreateInput {
  create: [ResearcherCreateInput!]
  connect: [ResearcherWhereUniqueInput!]
}

input ResearchAreaRelateToOneForCreateInput {
  create: ResearchAreaCreateInput
  connect: ResearchAreaWhereUniqueInput
}

type Event {
  id: ID!
  title: String
  slug: String
  keywords: String
  resume: String
  content: Event_content_Document
  image: ImageFieldOutput
  link: String
  workload: Int
  date: CalendarDay
  locale: String
  publishedAt: DateTime
  status: String
}

type Event_content_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

input EventWhereUniqueInput {
  id: ID
  slug: String
}

input EventWhereInput {
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
  id: IDFilter
  title: StringFilter
  slug: StringFilter
  keywords: StringFilter
  resume: StringFilter
  link: StringFilter
  workload: IntNullableFilter
  date: CalendarDayFilter
  locale: StringFilter
  publishedAt: DateTimeNullableFilter
  status: StringFilter
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntNullableFilter
}

input EventOrderByInput {
  id: OrderDirection
  title: OrderDirection
  slug: OrderDirection
  keywords: OrderDirection
  resume: OrderDirection
  link: OrderDirection
  workload: OrderDirection
  date: OrderDirection
  locale: OrderDirection
  publishedAt: OrderDirection
  status: OrderDirection
}

input EventUpdateInput {
  title: String
  slug: String
  keywords: String
  resume: String
  content: JSON
  image: ImageFieldInput
  link: String
  workload: Int
  date: CalendarDay
  locale: String
  publishedAt: DateTime
  status: String
}

input EventUpdateArgs {
  where: EventWhereUniqueInput!
  data: EventUpdateInput!
}

input EventCreateInput {
  title: String
  slug: String
  keywords: String
  resume: String
  content: JSON
  image: ImageFieldInput
  link: String
  workload: Int
  date: CalendarDay
  locale: String
  publishedAt: DateTime
  status: String
}

type Publication {
  id: ID!
  title: String
  slug: String
  keywords: String
  resume: String
  content: Publication_content_Document
  image: ImageFieldOutput
  link: String
  date: CalendarDay
  researchers(where: ResearcherWhereInput! = {}, orderBy: [ResearcherOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ResearcherWhereUniqueInput): [Researcher!]
  researchersCount(where: ResearcherWhereInput! = {}): Int
  researchArea: ResearchArea
  magazine: String
  doi: String
  license: String
  publishedAt: DateTime
  status: String
}

type Publication_content_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

input PublicationWhereUniqueInput {
  id: ID
  slug: String
}

input PublicationWhereInput {
  AND: [PublicationWhereInput!]
  OR: [PublicationWhereInput!]
  NOT: [PublicationWhereInput!]
  id: IDFilter
  title: StringFilter
  slug: StringFilter
  keywords: StringFilter
  resume: StringFilter
  link: StringFilter
  date: CalendarDayFilter
  researchers: ResearcherManyRelationFilter
  researchArea: ResearchAreaWhereInput
  magazine: StringFilter
  doi: StringFilter
  license: StringFilter
  publishedAt: DateTimeNullableFilter
  status: StringFilter
}

input PublicationOrderByInput {
  id: OrderDirection
  title: OrderDirection
  slug: OrderDirection
  keywords: OrderDirection
  resume: OrderDirection
  link: OrderDirection
  date: OrderDirection
  magazine: OrderDirection
  doi: OrderDirection
  license: OrderDirection
  publishedAt: OrderDirection
  status: OrderDirection
}

input PublicationUpdateInput {
  title: String
  slug: String
  keywords: String
  resume: String
  content: JSON
  image: ImageFieldInput
  link: String
  date: CalendarDay
  researchers: ResearcherRelateToManyForUpdateInput
  researchArea: ResearchAreaRelateToOneForUpdateInput
  magazine: String
  doi: String
  license: String
  publishedAt: DateTime
  status: String
}

input PublicationUpdateArgs {
  where: PublicationWhereUniqueInput!
  data: PublicationUpdateInput!
}

input PublicationCreateInput {
  title: String
  slug: String
  keywords: String
  resume: String
  content: JSON
  image: ImageFieldInput
  link: String
  date: CalendarDay
  researchers: ResearcherRelateToManyForCreateInput
  researchArea: ResearchAreaRelateToOneForCreateInput
  magazine: String
  doi: String
  license: String
  publishedAt: DateTime
  status: String
}

type TeamMember {
  id: ID!
  name: String
  role: String
  image: ImageFieldOutput
  link: String
  publishedAt: DateTime
  status: String
}

input TeamMemberWhereUniqueInput {
  id: ID
}

input TeamMemberWhereInput {
  AND: [TeamMemberWhereInput!]
  OR: [TeamMemberWhereInput!]
  NOT: [TeamMemberWhereInput!]
  id: IDFilter
  name: StringFilter
  role: StringFilter
  link: StringFilter
  publishedAt: DateTimeNullableFilter
  status: StringFilter
}

input TeamMemberOrderByInput {
  id: OrderDirection
  name: OrderDirection
  role: OrderDirection
  link: OrderDirection
  publishedAt: OrderDirection
  status: OrderDirection
}

input TeamMemberUpdateInput {
  name: String
  role: String
  image: ImageFieldInput
  link: String
  publishedAt: DateTime
  status: String
}

input TeamMemberUpdateArgs {
  where: TeamMemberWhereUniqueInput!
  data: TeamMemberUpdateInput!
}

input TeamMemberCreateInput {
  name: String
  role: String
  image: ImageFieldInput
  link: String
  publishedAt: DateTime
  status: String
}

type ResearchArea {
  id: ID!
  title: String
  resume: String
  content: ResearchArea_content_Document
  image: ImageFieldOutput
  icon: ImageFieldOutput
  projects(where: ProjectWhereInput! = {}, orderBy: [ProjectOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProjectWhereUniqueInput): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  publications(where: PublicationWhereInput! = {}, orderBy: [PublicationOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: PublicationWhereUniqueInput): [Publication!]
  publicationsCount(where: PublicationWhereInput! = {}): Int
  publishedAt: DateTime
  status: String
}

type ResearchArea_content_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

input ResearchAreaWhereUniqueInput {
  id: ID
}

input ResearchAreaWhereInput {
  AND: [ResearchAreaWhereInput!]
  OR: [ResearchAreaWhereInput!]
  NOT: [ResearchAreaWhereInput!]
  id: IDFilter
  title: StringFilter
  resume: StringFilter
  projects: ProjectManyRelationFilter
  publications: PublicationManyRelationFilter
  publishedAt: DateTimeNullableFilter
  status: StringFilter
}

input ProjectManyRelationFilter {
  every: ProjectWhereInput
  some: ProjectWhereInput
  none: ProjectWhereInput
}

input PublicationManyRelationFilter {
  every: PublicationWhereInput
  some: PublicationWhereInput
  none: PublicationWhereInput
}

input ResearchAreaOrderByInput {
  id: OrderDirection
  title: OrderDirection
  resume: OrderDirection
  publishedAt: OrderDirection
  status: OrderDirection
}

input ResearchAreaUpdateInput {
  title: String
  resume: String
  content: JSON
  image: ImageFieldInput
  icon: ImageFieldInput
  projects: ProjectRelateToManyForUpdateInput
  publications: PublicationRelateToManyForUpdateInput
  publishedAt: DateTime
  status: String
}

input ProjectRelateToManyForUpdateInput {
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  create: [ProjectCreateInput!]
  connect: [ProjectWhereUniqueInput!]
}

input PublicationRelateToManyForUpdateInput {
  disconnect: [PublicationWhereUniqueInput!]
  set: [PublicationWhereUniqueInput!]
  create: [PublicationCreateInput!]
  connect: [PublicationWhereUniqueInput!]
}

input ResearchAreaUpdateArgs {
  where: ResearchAreaWhereUniqueInput!
  data: ResearchAreaUpdateInput!
}

input ResearchAreaCreateInput {
  title: String
  resume: String
  content: JSON
  image: ImageFieldInput
  icon: ImageFieldInput
  projects: ProjectRelateToManyForCreateInput
  publications: PublicationRelateToManyForCreateInput
  publishedAt: DateTime
  status: String
}

input ProjectRelateToManyForCreateInput {
  create: [ProjectCreateInput!]
  connect: [ProjectWhereUniqueInput!]
}

input PublicationRelateToManyForCreateInput {
  create: [PublicationCreateInput!]
  connect: [PublicationWhereUniqueInput!]
}

type Researcher {
  id: ID!
  name: String
  projects(where: ProjectWhereInput! = {}, orderBy: [ProjectOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProjectWhereUniqueInput): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  publications(where: PublicationWhereInput! = {}, orderBy: [PublicationOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: PublicationWhereUniqueInput): [Publication!]
  publicationsCount(where: PublicationWhereInput! = {}): Int
  publishedAt: DateTime
  status: String
}

input ResearcherWhereUniqueInput {
  id: ID
}

input ResearcherWhereInput {
  AND: [ResearcherWhereInput!]
  OR: [ResearcherWhereInput!]
  NOT: [ResearcherWhereInput!]
  id: IDFilter
  name: StringFilter
  projects: ProjectManyRelationFilter
  publications: PublicationManyRelationFilter
  publishedAt: DateTimeNullableFilter
  status: StringFilter
}

input ResearcherOrderByInput {
  id: OrderDirection
  name: OrderDirection
  publishedAt: OrderDirection
  status: OrderDirection
}

input ResearcherUpdateInput {
  name: String
  projects: ProjectRelateToManyForUpdateInput
  publications: PublicationRelateToManyForUpdateInput
  publishedAt: DateTime
  status: String
}

input ResearcherUpdateArgs {
  where: ResearcherWhereUniqueInput!
  data: ResearcherUpdateInput!
}

input ResearcherCreateInput {
  name: String
  projects: ProjectRelateToManyForCreateInput
  publications: PublicationRelateToManyForCreateInput
  publishedAt: DateTime
  status: String
}

type NewsletterList {
  id: ID!
  email: String
}

input NewsletterListWhereUniqueInput {
  id: ID
  email: String
}

input NewsletterListWhereInput {
  AND: [NewsletterListWhereInput!]
  OR: [NewsletterListWhereInput!]
  NOT: [NewsletterListWhereInput!]
  id: IDFilter
  email: StringFilter
}

input NewsletterListOrderByInput {
  id: OrderDirection
  email: OrderDirection
}

input NewsletterListUpdateInput {
  email: String
}

input NewsletterListUpdateArgs {
  where: NewsletterListWhereUniqueInput!
  data: NewsletterListUpdateInput!
}

input NewsletterListCreateInput {
  email: String
}

type Company {
  id: ID!
  title: String
  address: String
  phone: String
  email: String
  facebookUrl: String
  instagramUrl: String
  youtubeUrl: String
}

input CompanyWhereUniqueInput {
  id: ID
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
  id: IDFilter
  title: StringFilter
  address: StringFilter
  phone: StringFilter
  email: StringFilter
  facebookUrl: StringFilter
  instagramUrl: StringFilter
  youtubeUrl: StringFilter
}

input CompanyOrderByInput {
  id: OrderDirection
  title: OrderDirection
  address: OrderDirection
  phone: OrderDirection
  email: OrderDirection
  facebookUrl: OrderDirection
  instagramUrl: OrderDirection
  youtubeUrl: OrderDirection
}

input CompanyUpdateInput {
  title: String
  address: String
  phone: String
  email: String
  facebookUrl: String
  instagramUrl: String
  youtubeUrl: String
}

input CompanyUpdateArgs {
  where: CompanyWhereUniqueInput! = {id: 1}
  data: CompanyUpdateInput!
}

input CompanyCreateInput {
  title: String
  address: String
  phone: String
  email: String
  facebookUrl: String
  instagramUrl: String
  youtubeUrl: String
}

type SectionContent {
  id: ID!
  title: String
  content: String
  section: SectionContentSectionType
}

enum SectionContentSectionType {
  HOME_HERO
  RESEARCH_HERO
  TEAM_HERO
  PUBLICATIONS_HERO
  EVENTS_HERO
  ACTIONS_HERO
  PROJECTS_HERO
  HISTORY_HERO
  HISTORY_SECTION
}

input SectionContentWhereUniqueInput {
  id: ID
}

input SectionContentWhereInput {
  AND: [SectionContentWhereInput!]
  OR: [SectionContentWhereInput!]
  NOT: [SectionContentWhereInput!]
  id: IDFilter
  title: StringFilter
  content: StringFilter
  section: SectionContentSectionTypeNullableFilter
}

input SectionContentSectionTypeNullableFilter {
  equals: SectionContentSectionType
  in: [SectionContentSectionType!]
  notIn: [SectionContentSectionType!]
  not: SectionContentSectionTypeNullableFilter
}

input SectionContentOrderByInput {
  id: OrderDirection
  title: OrderDirection
  content: OrderDirection
  section: OrderDirection
}

input SectionContentUpdateInput {
  title: String
  content: String
  section: SectionContentSectionType
}

input SectionContentUpdateArgs {
  where: SectionContentWhereUniqueInput!
  data: SectionContentUpdateInput!
}

input SectionContentCreateInput {
  title: String
  content: String
  section: SectionContentSectionType
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createAction(data: ActionCreateInput!): Action
  createActions(data: [ActionCreateInput!]!): [Action]
  updateAction(where: ActionWhereUniqueInput!, data: ActionUpdateInput!): Action
  updateActions(data: [ActionUpdateArgs!]!): [Action]
  deleteAction(where: ActionWhereUniqueInput!): Action
  deleteActions(where: [ActionWhereUniqueInput!]!): [Action]
  createProject(data: ProjectCreateInput!): Project
  createProjects(data: [ProjectCreateInput!]!): [Project]
  updateProject(where: ProjectWhereUniqueInput!, data: ProjectUpdateInput!): Project
  updateProjects(data: [ProjectUpdateArgs!]!): [Project]
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteProjects(where: [ProjectWhereUniqueInput!]!): [Project]
  createEvent(data: EventCreateInput!): Event
  createEvents(data: [EventCreateInput!]!): [Event]
  updateEvent(where: EventWhereUniqueInput!, data: EventUpdateInput!): Event
  updateEvents(data: [EventUpdateArgs!]!): [Event]
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteEvents(where: [EventWhereUniqueInput!]!): [Event]
  createPublication(data: PublicationCreateInput!): Publication
  createPublications(data: [PublicationCreateInput!]!): [Publication]
  updatePublication(where: PublicationWhereUniqueInput!, data: PublicationUpdateInput!): Publication
  updatePublications(data: [PublicationUpdateArgs!]!): [Publication]
  deletePublication(where: PublicationWhereUniqueInput!): Publication
  deletePublications(where: [PublicationWhereUniqueInput!]!): [Publication]
  createTeamMember(data: TeamMemberCreateInput!): TeamMember
  createTeamMembers(data: [TeamMemberCreateInput!]!): [TeamMember]
  updateTeamMember(where: TeamMemberWhereUniqueInput!, data: TeamMemberUpdateInput!): TeamMember
  updateTeamMembers(data: [TeamMemberUpdateArgs!]!): [TeamMember]
  deleteTeamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  deleteTeamMembers(where: [TeamMemberWhereUniqueInput!]!): [TeamMember]
  createResearchArea(data: ResearchAreaCreateInput!): ResearchArea
  createResearchAreas(data: [ResearchAreaCreateInput!]!): [ResearchArea]
  updateResearchArea(where: ResearchAreaWhereUniqueInput!, data: ResearchAreaUpdateInput!): ResearchArea
  updateResearchAreas(data: [ResearchAreaUpdateArgs!]!): [ResearchArea]
  deleteResearchArea(where: ResearchAreaWhereUniqueInput!): ResearchArea
  deleteResearchAreas(where: [ResearchAreaWhereUniqueInput!]!): [ResearchArea]
  createResearcher(data: ResearcherCreateInput!): Researcher
  createResearchers(data: [ResearcherCreateInput!]!): [Researcher]
  updateResearcher(where: ResearcherWhereUniqueInput!, data: ResearcherUpdateInput!): Researcher
  updateResearchers(data: [ResearcherUpdateArgs!]!): [Researcher]
  deleteResearcher(where: ResearcherWhereUniqueInput!): Researcher
  deleteResearchers(where: [ResearcherWhereUniqueInput!]!): [Researcher]
  createNewsletterList(data: NewsletterListCreateInput!): NewsletterList
  createNewsletterLists(data: [NewsletterListCreateInput!]!): [NewsletterList]
  updateNewsletterList(where: NewsletterListWhereUniqueInput!, data: NewsletterListUpdateInput!): NewsletterList
  updateNewsletterLists(data: [NewsletterListUpdateArgs!]!): [NewsletterList]
  deleteNewsletterList(where: NewsletterListWhereUniqueInput!): NewsletterList
  deleteNewsletterLists(where: [NewsletterListWhereUniqueInput!]!): [NewsletterList]
  createCompany(data: CompanyCreateInput!): Company
  createCompanies(data: [CompanyCreateInput!]!): [Company]
  updateCompany(where: CompanyWhereUniqueInput! = {id: 1}, data: CompanyUpdateInput!): Company
  updateCompanies(data: [CompanyUpdateArgs!]!): [Company]
  deleteCompany(where: CompanyWhereUniqueInput! = {id: 1}): Company
  deleteCompanies(where: [CompanyWhereUniqueInput!]!): [Company]
  createSectionContent(data: SectionContentCreateInput!): SectionContent
  createSectionContents(data: [SectionContentCreateInput!]!): [SectionContent]
  updateSectionContent(where: SectionContentWhereUniqueInput!, data: SectionContentUpdateInput!): SectionContent
  updateSectionContents(data: [SectionContentUpdateArgs!]!): [SectionContent]
  deleteSectionContent(where: SectionContentWhereUniqueInput!): SectionContent
  deleteSectionContents(where: [SectionContentWhereUniqueInput!]!): [SectionContent]
  endSession: Boolean!
  authenticateUserWithPassword(email: String!, password: String!): UserAuthenticationWithPasswordResult
  createInitialUser(data: CreateInitialUserInput!): UserAuthenticationWithPasswordSuccess!
}

union UserAuthenticationWithPasswordResult = UserAuthenticationWithPasswordSuccess | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String
  email: String
  password: String
}

type Query {
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: UserWhereUniqueInput): [User!]
  usersCount(where: UserWhereInput! = {}): Int
  action(where: ActionWhereUniqueInput!): Action
  actions(where: ActionWhereInput! = {}, orderBy: [ActionOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ActionWhereUniqueInput): [Action!]
  actionsCount(where: ActionWhereInput! = {}): Int
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput! = {}, orderBy: [ProjectOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ProjectWhereUniqueInput): [Project!]
  projectsCount(where: ProjectWhereInput! = {}): Int
  event(where: EventWhereUniqueInput!): Event
  events(where: EventWhereInput! = {}, orderBy: [EventOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: EventWhereUniqueInput): [Event!]
  eventsCount(where: EventWhereInput! = {}): Int
  publication(where: PublicationWhereUniqueInput!): Publication
  publications(where: PublicationWhereInput! = {}, orderBy: [PublicationOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: PublicationWhereUniqueInput): [Publication!]
  publicationsCount(where: PublicationWhereInput! = {}): Int
  teamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  teamMembers(where: TeamMemberWhereInput! = {}, orderBy: [TeamMemberOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: TeamMemberWhereUniqueInput): [TeamMember!]
  teamMembersCount(where: TeamMemberWhereInput! = {}): Int
  researchArea(where: ResearchAreaWhereUniqueInput!): ResearchArea
  researchAreas(where: ResearchAreaWhereInput! = {}, orderBy: [ResearchAreaOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ResearchAreaWhereUniqueInput): [ResearchArea!]
  researchAreasCount(where: ResearchAreaWhereInput! = {}): Int
  researcher(where: ResearcherWhereUniqueInput!): Researcher
  researchers(where: ResearcherWhereInput! = {}, orderBy: [ResearcherOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: ResearcherWhereUniqueInput): [Researcher!]
  researchersCount(where: ResearcherWhereInput! = {}): Int
  newsletterList(where: NewsletterListWhereUniqueInput!): NewsletterList
  newsletterLists(where: NewsletterListWhereInput! = {}, orderBy: [NewsletterListOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: NewsletterListWhereUniqueInput): [NewsletterList!]
  newsletterListsCount(where: NewsletterListWhereInput! = {}): Int
  company(where: CompanyWhereUniqueInput! = {id: 1}): Company
  companies(where: CompanyWhereInput! = {id: {equals: 1}}, orderBy: [CompanyOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: CompanyWhereUniqueInput): [Company!]
  companiesCount(where: CompanyWhereInput! = {id: {equals: 1}}): Int
  sectionContent(where: SectionContentWhereUniqueInput!): SectionContent
  sectionContents(where: SectionContentWhereInput! = {}, orderBy: [SectionContentOrderByInput!]! = [], take: Int, skip: Int! = 0, cursor: SectionContentWhereUniqueInput): [SectionContent!]
  sectionContentsCount(where: SectionContentWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  graphql: KeystoneAdminUIGraphQL!
  initialColumns: [String!]!
  initialSearchFields: [String!]!
  initialSort: KeystoneAdminUISort
  isSingleton: Boolean!
  hideCreate: Boolean!
  hideDelete: Boolean!
  isHidden: Boolean!
  itemQueryName: String!
  listQueryName: String!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

enum KeystoneAdminUIFieldMetaIsNonNull {
  read
  create
  update
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

type KeystoneAdminUIFieldGroupMeta {
  label: String!
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUIGraphQL {
  names: KeystoneAdminUIGraphQLNames!
}

type KeystoneAdminUIGraphQLNames {
  outputTypeName: String!
  whereInputName: String!
  whereUniqueInputName: String!
  createInputName: String!
  createMutationName: String!
  createManyMutationName: String!
  relateToOneForCreateInputName: String!
  relateToManyForCreateInputName: String!
  itemQueryName: String!
  listOrderName: String!
  listQueryCountName: String!
  listQueryName: String!
  updateInputName: String!
  updateMutationName: String!
  updateManyInputName: String!
  updateManyMutationName: String!
  relateToOneForUpdateInputName: String!
  relateToManyForUpdateInputName: String!
  deleteMutationName: String!
  deleteManyMutationName: String!
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
